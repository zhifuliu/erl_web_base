# gen_tcp 提供的所有接口

参考：<http://dhq.me/erlample/modules/gen_tcp/accept_1.html?search=gen_tcp&i=1>

api name  | return value                                                                | remark
:-------- | :-------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
accept/1  | accept(ListenSocket) -> {ok, Socket} or {error, Reason}                     | 接受一个发送到肩痛套接字 ListenSocket 上的连接请求。ListenSocket 必须是由函数 gen_tcp:listen/2 建立返回。该函数会引起进程阻塞，直到有一个连接请求发送到监听的套接字。如果连接已建立，则返回 {ok, Socket};或如果 ListenSocket 已经关闭，则返回 {error, closed}; 或如果在指定的时间内连接没有建立，则返回 {error, timeout};erlang 可用的虚拟机端口被使用，返回{error, system_limit};如果某些东西出错，也可能返回一个 POSIX 错误。一些有可能的错误请查看 inet 模块的想过说明。使用 gen_tcp:send/2 向该函数返回的套接字 Socket 发送数据包。往端口发送的数据包会以下面的消息发送：{tcp, Socket, Data};如果在建立套接字 Sockrt 的时候选项列表中指定了 {active, false},这样只能使用 gen_tcp:recv/2 或 gen_tcp:recv/3 来接受数据包了 |
accept/2  | accept(ListenSocket, Timeout) -> {ok, Socket} or {error, Reason}            | 和 accept/1 一样，就是多设置了一个超时时间                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
close/1   | close(Socket) -> ok                                                         | 关闭一个 TCP 套接字，这个套接字由 accept 返回                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
connect/3 | connect(Address, Port, Options) -> {ok, Socket} or {error, Reason}          | 用给定的端口 Port 和 IP 地址 Address 连接到服务器上的一个 TCP 端口上。参数 Address 可以是一个主机名，也可以是一个地址                                                                                                                                                                                                                                                                                                                                                                                                                  |
connect/4 | connect(Address, Port, Options, Timeout) -> {ok, Socket} or {error, Reason} | 和 connect/3 一样，就是多了一个超时时间参数                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | controlling_process/2 | controlling_process(Socket, Pid) -> ok or {errorm, Reason} | 改变一个套接字的控制进程。为 Socket 分配一个新的控制进程 Pid。控制进程就是接受发自套接字消息数据的进程。如果被当前控制进程意外的凄然任何进程调用，则返回 {error, not_owner} 的错误。 | listen/2 | listen(Port, Options) -> {ok, ListenSocket} or {error, Reason} | 在本地开启一个监听某个端口的套接字（socket）。开启成功的话，会返回一个套接字表示服 Sockrt，其一般会传递给 gen_tcp:accept/1 或 gen_tcp:accept/2 调用。如果参数 Port 为 0，那么底层操作系统将赋值一个可用的端口号，可以使用 inet:port/1 来获取一个 socket 监听的端口。options 常用选项见下一个表格 |
recv/2    | recv(Socket, Length) -> {ok, Packet} or {error, Reason}                     | 从一个被动模式的套接字接收一个数据包                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | recv/3 | recv(Socket, Length, Timeout) -> {ok, Packet} or {error, Reason} | 和 recv/2 一样，多一个超时时间值参数 | send/2 | send(Socket, Packet) -> ok or {error, Reason} | 在一个套接字 Socket 发送一个数据包 | shutDown/2 | shutDown(Socket, How) -> ok or {error, Reason} | 半关闭一个套接字。以某种方式半关闭一个套套接字，如果参数How 为 write 的形式，则套接字 socket 会关闭数据写入，读取仍可以正常执行 |
